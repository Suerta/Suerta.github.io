[{"title":"Linux的常用命令学习","date":"2021-06-29T06:52:24.233Z","path":"2021/06/29/Linux命令学习/","text":"本文主要用于记录常用的linux相关语句。 Linux的常用命令学习写在最前：由于才刚开始学习Linux，很多命令的具体用法没有深挖。本文只记录了相关命名的基础用法，之后用到或者时间足够充裕，再学习进行记录。人的学习能力是无穷的，但是记忆的能力是有限的。俗话说得好，好记性不如烂笔头。记录下来再多看看，一是为了避免到处扒文件的尴尬，一是为了自己没事的时候想看就看，难度不大但是是真的多。 一、文件目录信息1.1.cd命令[改变当前路径] cd [目录名] 进入目录名下的文件 特殊目录的表示方法 含义 . 代表当前的目录 .. 代表上层的目录 ~ 代表当前登陆用户的宿主目录 ~用户名 进入~后用户的宿主目录 - 历史记录的上一级目录 直接在命令行中输入cd命令而不添加任何的参数，可以马上回到用户的主目录（home） 1.2.mkdir命令[创建目录]1# mkdir 目录名 其实一个目录就是一个特殊类型的文件，就如同Windows中的文件夹一样，目录里面既可以有文件，也可以有子目录，就是因为有目录的存在，Linux才能够以一种目录树的结构对文件系统进行管理。 有时候我们需要一次性地建立多级目录，则可以使用-p参数： 1# mkdir -p /home/dir1/dir2/dir3 1.3.rm命令[删除文件/目录命令] 删除空目录的命令：rmdir 1# rmdir 目录名[路径eg:# rmdir /home/directory] 对于目录来说，如果里面为空的时候可以使用rmdir命令来删除，并且此命令只能用来删除空目录，如果是非空目录，则需要使用下面要介绍的rm 命令。 rm命令 能够删除一个目录或者是一个文件 1# rm [-选项] 文件名或者目录名 rm命令选项 参数说明 -f 强制删除（即使设置了-i 属性也不起作用）不询问 -r 删除目录 递归删除目录 -i 删除文件或者目录前询问 总结：关于文件路径信息的命令还有很多，比如查看当前目录是什么，使用pwd， 二、文件属性信息2.1. ls命令 查看文件价下的文件 ls命令的选项列表 命令选项说明 -a 列出所有的文件，包括隐藏文件 -l 详细信息，包括文件名，大小，访问权限等 -R 列出目录下的所有内容，包括子目录的内容 -d 仅列出目录本身，而不显示当前目录下的内容 2.2.chmod[更改文件属性] chmod [-R] xyz 文件或目录 权限操作对应的文件命令 Linux的文件属性的设置方式有连中国，一种是数字，一种是符号。 Linux的文件的基本权限就有九个，分别是owner/group/others三种身份，有对应的read/write/excute权限。 123456r:4 w:2 x:1 可读可写可执行：7可写可读不执行：6chomd 777 fileName #文件赋予所有用户可读可写可执行的权限。 2.3.chgrp[更改文件属组]1chgrp [-R] 属组名 文件名 -R：递归更改文件属组。就是在更改某个目录文件的数组时，如果加上-R参数，那么该目录下的所有文件属性都会被更改。 2.4.chown[更改文件属主，也可更改文件属组]12chown [-R] 属主名 文件名chown [-R] 属主名:属组名 文件名 2.5touch命令[改变文件的创建时间或创建空文件]touch命令能够创建一个空白文件，或者改变文件的创建时间。 1#touch 文件名 同时创建多个文件 12# touch a.txt b.txt# touch &#123;1..5&#125;.txt 实际上，对于touch命令来说，其最主要的功能是改变文件的时间，那么一个文件拥有哪些时间属性呢？对于一个文件来说，主要有三种时间属性，分别为： （1）mtime：这个时间记录的是文件内容被修改的时间。 （2）ctime：这个时间记录的是文件的属性（所有者、所属组、文件名）或者权限被修改的时间。 （3）atime：这个时间记录的是文件的内容被读取的时间。 详情再看一遍该网址：https://www.linuxprobe.com/linux-touch-command.html 总结：三、文件压缩命令3.1.gzip命令[压缩] gzip命令能够压缩和解压以.gz为结尾的文件 1#gzip [-选项] 文件名 **gzip **命令是Linux比较常见的压缩命令之一，它能够产生以.gz为后缀名的压缩文件。 例如现在我们要对/home/file文件进行压缩，执行命令： 1# gzip /home/file 压缩完成后会发现原来的file文件已经变成了file.gz文件，原文件已经消失。 还可以在压缩过程中指定压缩的百分比，gzip命令提供了1-9级的压缩比，１的压缩比最差，但是压缩速度比较快，而9的压缩比最好，但是速度比较慢，默认的级别是6，例如： 1# gzip -1 file gzip命令不但能够压缩文件，还可以将压缩的文件（.gz）解开，例如： 1# gzip -d file.gz gzip命令的常见选项见下表： gzip的命令选项 选项说明 -d 解压 -n(n=1~9) 指定 总结：关于压缩的命令我单独整理了 四、文件内容查看网络配置目录：cd /etc/sysconfig/network-scripts centOS7 查看网络配置：ifconfig 命令 4.1.cat命令[正向显示文件内容|拼接]cat由第一行开始显示文件内容，用来读文章，或者读取配置文件。 cat命令能显示一个文件的内容 查看etc目录下的ifcfg-ens33文件 eg: # cat incfg-ens33 1# cat 文件名 文件合并 eg: # cat /etc/passwd &gt;&gt; /home/passwd_bak 加上&gt;&gt;符号后，前面一个文件的内容就添加到后面一个文件的内容中。第一个文件内容不变。 不加&gt;&gt;符号，使用命令#cat ttfile ccfile对文件不会有任何改变，只是一个临时的合并显示。即都显示在面板上，不更改文件。 1# cat 文件名 文件名 缺点：cat查看文件的时候只能查看当前页的内容，如果文件内容超过了当前页面所能容纳的行数。 解决：more、head、tail 4.2.tac命令[反向查看文件内容]反向查看文件的内容，从最后的内容进行展示。 1# tac 文件名 4.3.nl命令[内容加行号信息]1#nl 文件名 3.4.more命令[分屏显示文件]more命令可以单独使用，也可以和配合管道符使用。它的主要作用是能够将屏幕输出的结果分屏显示。空格键分页，回车键下一行。 1# more 文件名 配合管道命令符使用： 1# cat /mnt/tttfile | more 显示效果和直接使用more＋对应的名字没什么区别，都可以使用空格键进行翻页。 4.5.less[分屏显示文件]1less 文件名 使用less，和more不同的是，less查看的内容可以向上滚动，即通过上下键逐行进行查看。 4.5.head命令[从头开始查看文件内容] head命令能够从头开始显示文件内容，并且能够设定查看的行数。 n为数字，即设定的函数。 1# head [-n] 文件名 head命令能够从文件开始处查看一个文件的指定的行数，如果没有指定行数的话，默认是显示前十行。 head -n 20 network-functions 4.6.tail命令[从尾开始查看文件内容]1#dail [-n] 文件名 eg: #tail -5 network-functions 4.7.diff命令[文件比较]diff命令能够比较两个文件的差异 1# diff [-选项] 文件一 文件二 还有一个功能，查询文件夹里是否存在查询文件，然后和目前的文件进行比较。 1# diff 123.text 1234.text 只把不一样的文件内容进行显示。 4.8.sort命令[排序]1# sort [-选项] 文件名 sort命令可以对指定文件中的所有行进行排序，它的排序是根据从指定的行抽取一个或多个进行排序 1 sort命令选项 参数说明 -f 忽略大小写 -r 方向排序 -t 指定分隔符 -k 以第几个区间进行排序，后面加数字 4.9.wc命令[统计]1# wc [-选项] 文件名 wc命令选项 参数说明 -l 显示行数 -w 显示单词数 -m 显示字符数 如果不添加参数的话，直接使用wc加文件名显示的就是 行数 单词数 字符数【其中字符数包括英文之间的空格】 总结：文件查看状态下，进行关键词搜索的命令 ①/+关键词向下查询 ②？+关键词向上查询 其中，在英文输入的状态下，按n键进行逐个查询（大写往上查看，小写的往下查看）。 五、文件移动命令5.1.cp命令[复制命令]cp命令能够复制一个文件或者生成一个不同名但是内容相同的文件。 复制文件 eg: # cp /etc/passwd /home 1# cp源文件名 目标路径 生成文件内容相同但是名字不同的文件 eg: # cp passwd passwd_new 1# cp源文件名 目标文件名 命令选项 参数说明 -a 此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d 复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。 -f 覆盖已经存在的目标文件而不给出提示。 -i 与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。 -p 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r 若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l 不复制文件，只是生成链接文件。 5.2.mv命令[移动] 移动文件 eg: #mv testfile /mnt 1# mv要移动的文件 目标路径 给原文件改名字 eg: #mv testfile ttfile 【执行以后查看ls，发现testfile已经改名为ttfile了】 1# mv原文件名 新文件名 六、其他6.1.clear[页面清空]该命令有一个快捷键 【ctrl+L】 清空当前所有的命令行和界面的所有东西。【影响的只是视觉上的信息，不影响内容上的东西】","tags":[{"name":"Linux","slug":"Linux","permalink":"https://suerta.github.io/tags/Linux/"}]},{"title":"springBoot学习","date":"2021-03-11T02:11:47.986Z","path":"2021/03/11/springBoot学习/","text":"整理springboot从入门到源码的学习，了解其概貌以及深层原理。 一、springBoot核心技术1.spring基础入门(一)springBoot介绍 简化spring应用开发的一个框架 整个spring技术栈的一个大整合 J2EE开发的一站式解决方案 (二)微服务 架构风格 一个应用应该是一组小型服务；可以通过http的方式进行互通； (三)环境约束 jdk1.8 : SpringBoot1.7及以上； maven3.X : maven3.3以上版本[相对来说更加的稳定] IDEA2017及以上 springBoot1.5.9 RELEASE (四)环境配置 123456789//Maven的setting.xml&lt;!-- 国内远程仓库：阿里云镜像 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 123456789101112131415161718192021222324252627282930313233343536373839//pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;description/&gt; &lt;developers&gt; &lt;developer/&gt; &lt;/developers&gt; &lt;licenses&gt; &lt;license/&gt; &lt;/licenses&gt; &lt;scm&gt; &lt;url/&gt; &lt;/scm&gt; &lt;url/&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; (五)hello world ①主程序 12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** *@SpringBootApplication 用于标注主程序类，说明这是一个springboot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //springboot应用启动 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; ②业务层 12345678910111213import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class ApplicationController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String sayHello()&#123; return &quot;hey guys!&quot;; &#125;&#125; ③简化部署 123456789&lt;!-- 将应用打包成一个可执行的jar包 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; maven -&gt; lifecycle -&gt;package进行打包 在D:\\exploit\\project\\webProject\\springBootdamo2\\target目录下执行 java -jar 生成的jar包的名字【该目录为package打包成功的位置，一般在项目的target中，日志文件中会记录】 刷新页面，依旧出现helloworld，环境中没有tomcat也没事。因为打包插件中已经存在了。 2.spring核心功能1. helloworld探究（一）pom文件1234567&lt;!-- 父项目 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;/parent&gt; 👆↑的父项目是👇↓ 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/parent&gt; 再点进去看，会看到springboot将需要的插件都进行了依赖管理，也就是说👆↑是真正来管理springBoot应用里面中的所有版本依赖。即springBoot版本仲裁中心。因此导入依赖时可以不用写版本号。没有在dependencies中管理的需要写。 （二）导入的依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-start : springBoot场景启动器；帮我们导入了web模块需要正常运行所依赖的组件； springBoot将所有的场景都抽取出来，做成一个个starters（启动器），只需要在项目里引用这些starter相关场景的所有依赖，需要什么样的功能就导入什么样的启动器。 （三）主程序类[主入口类] @SpringBootApplication:Springboot应用标注某个类上说明这个类是主程序类。Springboot就运行该类的main方法来启动应用。 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) @SpringBootConfiguration:springBoot的配置类 ​ 标注在某个类上，表示该类是一个配置类。 ​ @Configuration：配置类[曾经的配置文件]配置类也是容器的一个组件；@Component @EnableAutoConfiguration:开启自动配置功能； ​ @AutoConfigurationPackage:自动配置包 ​ @Import({Registrar.class}):spring底层注解。给容器中导入一个组件。将主配置类的所在包下边的所有子包中的所有组件扫描到spring容器中。 ​ @Import({AutoConfigurationImportSelector.class}):给容器中导入AutoConfigurationImportSelector组件。AutoConfigurationImportSelector将所有需要导入的组件以全类名的方式返回；这些组件就会添加到容器中。 3.spring场景整合二、springBoot响应式编程1.响应式编程基础2.webflux开发web应用3.响应式访问持久层4.响应式安全开发5.响应式原理","tags":[{"name":"spring","slug":"spring","permalink":"https://suerta.github.io/tags/spring/"}]},{"title":"Hello World","date":"2021-03-11T02:11:47.976Z","path":"2021/03/11/hello-world/","text":"我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后的你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://suerta.github.io/tags/%E6%9D%82%E8%B0%88/"}]}]